{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"observe\", {\n  enumerable: true,\n  get: function get() {\n    return _observerUtil.observe;\n  }\n});\nObject.defineProperty(exports, \"unobserve\", {\n  enumerable: true,\n  get: function get() {\n    return _observerUtil.unobserve;\n  }\n});\nexports.Component = exports.sharedComponentData = void 0;\n\nvar _react = require(\"react\");\n\nvar _observerUtil = require(\"@nx-js/observer-util\");\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar isNative = typeof HTMLElement == 'undefined';\nvar bindComponentExcludes = ['constructor', 'getSnapshotBeforeUpdate', 'render', 'updated', 'beforeUnmount'];\nvar bindInstanceExcludes = ['constructor', '__defineGetter__', '__defineSetter__', 'hasOwnProperty', '__lookupGetter__', '__lookupSetter__', 'isPrototypeOf', 'propertyIsEnumerable', 'toString', 'valueOf', '__proto__', 'toLocaleString'];\nvar observableExcludes = ['props', 'context', 'refs', 'updater', 'state'];\n\nvar sharedComponentData = function sharedComponentData(object) {\n  var shared = (0, _observerUtil.observable)(object); // Do not allow use of asynchronous operations in constructor, since changes to member variables will not be observed\n\n  var constructorStr = object.constructor.toString();\n  var idx = constructorStr.indexOf('\\n');\n\n  if (idx != -1) {\n    idx += 1;\n\n    while (constructorStr[idx] == ' ') {\n      idx += 1;\n    }\n\n    if (constructorStr.startsWith('var _this', idx)) throw new Error('Detected use of asynchronous operation in constructor. Use a separate function for such operations that you call after the sharedComponentData object has been made.');\n  } // Bind methods\n\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.getOwnPropertyNames(Object.getPrototypeOf(object))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var name = _step.value;\n      if (!bindInstanceExcludes.includes(name)) shared[name] = shared[name].bind(shared);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return shared;\n};\n\nexports.sharedComponentData = sharedComponentData; // The same observable must be used elsewhere or else components will not rerender\n\nvar Component =\n/*#__PURE__*/\nfunction (_ReactComponent) {\n  _inherits(Component, _ReactComponent);\n\n  _createClass(Component, null, [{\n    key: \"instance\",\n    // Returns the last instance\n    value: function instance() {\n      if (!Component.instances) return null;\n      var instances = Component.instances[this.name];\n      if (!instances || instances.length == 0) return null;\n      return instances[instances.length - 1];\n    }\n  }, {\n    key: \"instances\",\n    value: function instances() {\n      if (!Component.instances) return [];\n      var instances = Component.instances[this.name];\n      if (!instances) return [];\n      return instances;\n    }\n  }]);\n\n  function Component() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Component);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Component)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    if (!Component.instances) Component.instances = {};\n    var instances = Component.instances[_this.constructor.name];\n    if (!instances) instances = Component.instances[_this.constructor.name] = [];\n    instances.push(_assertThisInitialized(_this)); // Bind methods\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = Object.getOwnPropertyNames(Object.getPrototypeOf(_assertThisInitialized(_this)))[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var name = _step2.value;\n\n        if (!name.startsWith('shouldComponent') && !name.startsWith('componentWill') && !name.startsWith('componentDid') && !name.startsWith('UNSAFE_component') && !bindComponentExcludes.includes(name)) {\n          _this[name] = _this[name].bind(_assertThisInitialized(_this));\n        }\n      } // Create getters and setters for properties. Objects are made observable.\n\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    _this._reactSimplifiedRender = _this.render;\n    _this._reactSimplifiedVarsSet = false;\n\n    _this.render = function () {\n      if (!_this._reactSimplifiedVarsSet) {\n        _this._reactSimplifiedVarsSet = true;\n        var ownPropertyNames = Object.getOwnPropertyNames(_assertThisInitialized(_this));\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          var _loop = function _loop() {\n            var name = _step3.value;\n\n            if (typeof _this[name] != 'function' && !name.startsWith('_react') && !observableExcludes.includes(name)) {\n              if (typeof _this[name] == 'undefined') {\n                throw new Error('Detected uninitialized or undefined property ' + name + ' in class ' + _this.constructor.name + '. Since such properties are unsafe to use in controlled components, you must initialize this property or use null instead of undefined.');\n              }\n\n              if (_typeof(_this[name]) == 'object' && _this[name] != null) {\n                // Do not make React.createRef() objects observable\n                if (Object.isSealed(_this[name])) {\n                  var keys = Object.keys(_this[name]);\n                  if (keys.length == 1 && keys[0] == 'current') return \"continue\";\n                }\n\n                _this['_reactSimplifiedVar_' + name] = (0, _observerUtil.observable)(_this[name]);\n              } else {\n                _this['_reactSimplifiedVar_' + name] = _this[name];\n              }\n\n              Object.defineProperty(_assertThisInitialized(_this), name, {\n                get: function get() {\n                  return _this['_reactSimplifiedVar_' + name];\n                },\n                set: function set(value) {\n                  if (value instanceof _react.Component || !isNative && value instanceof HTMLElement) {\n                    _this['_reactSimplifiedNoRerenderVar_' + name] = true;\n                  }\n\n                  if (_typeof(value) == 'object' && value != null && !_this['_reactSimplifiedNoRerenderVar_' + name]) {\n                    _this['_reactSimplifiedVar_' + name] = (0, _observerUtil.observable)(value);\n                  } else {\n                    _this['_reactSimplifiedVar_' + name] = value;\n                  }\n\n                  if (!_this['_reactSimplifiedNoRerenderVar_' + name]) _this.setState({});\n                  return true;\n                }\n              });\n            }\n          };\n\n          for (var _iterator3 = ownPropertyNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _ret = _loop();\n\n            if (_ret === \"continue\") continue;\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      return _this._reactSimplifiedRender();\n    }; // Schedule rerender when observable objects change\n\n\n    _this.render = (0, _observerUtil.observe)(_this.render, {\n      scheduler: function scheduler() {\n        return _this.setState({});\n      },\n      lazy: true\n    });\n    _this._reactSimplifiedComponentDidMount = _this.componentDidMount;\n\n    _this.componentDidMount = function () {\n      if (_this.mounted) return _this.mounted();\n      if (_this._reactSimplifiedComponentDidMount) return _this._reactSimplifiedComponentDidMount();\n    }; // Disable rerender when component is about to be unmounted\n\n\n    _this._reactSimplifiedComponentWillUnmount = _this.componentWillUnmount;\n\n    _this.componentWillUnmount = function () {\n      var instances = Component.instances[_this.constructor.name];\n      instances.splice(instances.indexOf(_assertThisInitialized(_this)), 1);\n      (0, _observerUtil.unobserve)(_this.render);\n      if (_this.beforeUnmount) return _this.beforeUnmount();\n      if (_this._reactSimplifiedComponentWillUnmount) return _this._reactSimplifiedComponentWillUnmount();\n    }; // For easier react-router usage, call componentWillUnmount and componentDidMount when props.match.params changes.\n\n\n    _this._reactSimplifiedComponentDidUpdate = _this.componentDidUpdate;\n\n    _this.componentDidUpdate = function (prevProps, prevState, snapshot) {\n      if (_this.beforeUnmount || _this._reactSimplifiedComponentWillUnmount || _this.mounted || _this._reactSimplifiedComponentDidMount) {\n        if (!prevProps.match && _this.props.match || prevProps.match && !_this.props.match) {\n          if (_this.beforeUnmount) _this.beforeUnmount();else if (_this._reactSimplifiedComponentWillUnmount) _this._reactSimplifiedComponentWillUnmount();\n          if (_this.mounted) _this.mounted();else if (_this._reactSimplifiedComponentDidMount) _this._reactSimplifiedComponentDidMount();\n        } else if (prevProps.match && _this.props.match) {\n          var prevParams = prevProps.match.params;\n          var params = _this.props.match.params;\n\n          if (prevParams && params && _typeof(prevParams) == 'object' && _typeof(params) == 'object' ? Object.keys(prevParams).length != Object.keys(params).length || Object.keys(params).some(function (key) {\n            return prevParams[key] !== params[key];\n          }) : prevParams !== params) {\n            if (_this.beforeUnmount) _this.beforeUnmount();else if (_this._reactSimplifiedComponentWillUnmount) _this._reactSimplifiedComponentWillUnmount();\n            if (_this.mounted) _this.mounted();else if (_this._reactSimplifiedComponentDidMount) _this._reactSimplifiedComponentDidMount();\n          }\n        }\n      }\n\n      if (_this.updated) return _this.updated(prevProps, prevState, snapshot);\n      if (_this._reactSimplifiedComponentDidUpdate) return _this._reactSimplifiedComponentDidUpdate(prevProps, prevState, snapshot);\n    };\n\n    return _this;\n  }\n\n  return Component;\n}(_react.Component);\n\nexports.Component = Component;","map":null,"metadata":{},"sourceType":"script"}